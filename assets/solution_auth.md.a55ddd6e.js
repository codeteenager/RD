import{_ as e,o as i,c as o,V as a}from"./chunks/framework.ec431b68.js";const t="/RD/image/9.png",l="/RD/image/10.png",_=JSON.parse('{"title":"鉴权","description":"","frontmatter":{},"headers":[],"relativePath":"solution/auth.md","filePath":"solution/auth.md","lastUpdated":1686885421000}'),s={name:"solution/auth.md"},n=a('<h1 id="鉴权" tabindex="-1">鉴权 <a class="header-anchor" href="#鉴权" aria-label="Permalink to &quot;鉴权&quot;">​</a></h1><p>直接把API暴露到互联网上给外部系统是存在安全风险的，因此我们要先对接口调用方做一个用户鉴权，对API权限划分，如果鉴权通过则允许用户调用API。根据不同的场景，鉴权方案也有很多种。</p><h2 id="常见的鉴权方式" tabindex="-1">常见的鉴权方式 <a class="header-anchor" href="#常见的鉴权方式" aria-label="Permalink to &quot;常见的鉴权方式&quot;">​</a></h2><h3 id="session-cookie" tabindex="-1">Session/Cookie <a class="header-anchor" href="#session-cookie" aria-label="Permalink to &quot;Session/Cookie&quot;">​</a></h3><p>Cookie + Session是最传统的API鉴权方式，比如很多网站的登录模块就是靠这种方式实现会话管理。</p><p>在服务端会生成一个session来保存会话状态，各个session是通过唯一的session_id来标识的，一次判断请求是哪个客户端发起，session_id存储在客户端的cookie中。</p><p>后续的所有请求都会把cookie传到服务器端，服务器端解析cookie后找到对应的session进行判断。 <img src="'+t+'" alt=""></p><p>因此这种鉴权方式具有以下特点：</p><ul><li>为了使后台应用能识别是哪个用户发出的请求，需要在后台服务器存储一份用户登录信息(即session)，这份信息也会在响应前端请求时返回给前端，前端将其保存在cookie；</li><li>下次请求时前端发送给后端应用，后端应用就可以识别这个请求是来自哪个用户；</li><li>cookie内仅包含一个session标识符而诸如用户信息、授权列表等都保存在服务端的session中。</li></ul><p>其优点是：</p><ol><li>比较传统，对开发来说资料较多，语言支持完善；</li><li>较易于扩展，外部session存储方案已经非常成熟了（比如Redis）。</li></ol><p>但也有如下缺点：</p><ol><li>性能相于较低：每一个用户经过后端应用认证之后，后端应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大；</li><li>在一个无状态协议里注入了状态，与REST风格不匹配；</li><li>因为基于cookie来进行用户识别, cookie如果被截获，用户就会很容易受到CSRF攻击；</li><li>很难跨平台：在移动应用上 session 和 cookie 很难行通，你无法与移动终端共享服务器创建的 session 和 cookie。</li></ol><h3 id="api-key-api-secret" tabindex="-1">API Key + API Secret <a class="header-anchor" href="#api-key-api-secret" aria-label="Permalink to &quot;API Key + API Secret&quot;">​</a></h3><p>这种方式是指当请求的资源、API Key 和 API Secret匹配时，用户才可以访问对应的资源，一般还会以时间戳等方式来进行请求的时效控制。</p><p>其原理为：</p><ol><li>服务器给每个客户端生成一对Key/Secret保存，并告知客户端，Key和Secret之间没有任何关系，相互之间不能推算；</li><li>发起请求时，会把包括API Key在内的所有的请求参数排序，然后跟API Secret一起做hash生成一个sign参数，服务器只需要按照约定的规则做一次签名计算，然后和请求的签名作比较，如果一致，则验证通过。</li></ol><p>为了避免重放攻击，可以加上时间戳参数，服务端验证时，如果时间超过允许范围则验证失败。</p><p>需要注意的是，这种模式并不是RBAC，而是ACL访问权限控制。这种方式实现简单，占用的计算资源和网络资源都较少，安全性也可以。但是一般来说每一个api用户都需要分配一对Key和Secret，因此当Key和Secret比较多的时候，服务器会有一定的存储成本 ，而服务端只能通过API Key来区别调用者，API Secret一旦泄密，将造成很大的安全风险。</p><h3 id="token" tabindex="-1">token <a class="header-anchor" href="#token" aria-label="Permalink to &quot;token&quot;">​</a></h3><p>token令牌的机制是用来代替session的鉴权方式，现在很多api的鉴权都是通过token。</p><p><img src="'+l+'" alt=""></p><p>token机制是服务器端生成的一串加密串发放给客户端，客户端请求服务器端所有资源时会带上这个Token，由服务器端来校验这个token的合法性。其具有无状态、适合分布式、扩展性好、性能高和安全性好等优点。</p><p>常见的token实现有以下几种：</p><ul><li>自定义实现token：应用开发者根据token机制原理自行实现；</li><li>JWT：即Json Web Token，是一种主流的Token规范；</li><li>Oauth：Oauth虽然是授权规范，但其中也用到了Token；</li><li>HTTP Basic Authentication认证机制；</li><li>Web API是基于HTTP协议的，而HTTP协议本身就带有认证机制。</li></ul><h2 id="什么是jwt" tabindex="-1">什么是JWT? <a class="header-anchor" href="#什么是jwt" aria-label="Permalink to &quot;什么是JWT?&quot;">​</a></h2><p>JWT的全称是JSON Web Token，一个JWT由三部分构成：Header,Payload,Signature</p><ul><li>Header规定了token加密的方式和token的类型，</li><li>payload是token中包含用户的一些信息，比如用户名、过期时间</li><li>Signature包含header的base64值+payload的base64值+secret</li></ul><p>JWT的特点：</p><ul><li>防CSRF(主要是伪造请求，带上Cookie)</li><li>适合移动应用</li><li>无状态，编码数据</li></ul><p>在线JWT网站<a href="jwt.io">jwt.io</a></p><p>客户端往服务发送登录请求，服务端验证后，返回token给客户端，客户端每次请求接口的时候都会带上header部分带上token并进行请求。然后服务端使用secret进行解密，来验证从客户端传递过来的token是不是一个有效的token。如果验证通过则返回数据。</p><h2 id="算法-加密" tabindex="-1">算法/加密 <a class="header-anchor" href="#算法-加密" aria-label="Permalink to &quot;算法/加密&quot;">​</a></h2><p>算法中的指令描述的是一个计算，当其运行时能从一个初始状态和初始输入(可能为空)开始，经过一系列有限而清晰定义的状态最终产生输出并停止于一个终态。</p><p>数据加密的基本过程，就是对原来为明文的文件或数据按某种算法进行处理，使其称为不可读的一段代码，通常称为密文。通过这样的途径，来达到保护数据不被非法人窃取、阅读的目的。</p><h2 id="安全传输协议https" tabindex="-1">安全传输协议HTTPS <a class="header-anchor" href="#安全传输协议https" aria-label="Permalink to &quot;安全传输协议HTTPS&quot;">​</a></h2><p>HTTPS(HyperText Transfer Protocol Secure)超文本传输安全协议，常称为HTTP over TLS、HTTP over SSL或HTTP Secure)是一种通过计算机网络进行安全通信的传输协议。</p><p>那么API安全如何保障？</p><ul><li>通信信道加密：使用HTTPS</li><li>通信数据加密：密文+加密关键数据</li><li>通信安全策略：授权中间层、尝试次数、过期策略...</li></ul>',39),r=[n];function p(c,h,k,d,u,T){return i(),o("div",null,r)}const S=e(s,[["render",p]]);export{_ as __pageData,S as default};
