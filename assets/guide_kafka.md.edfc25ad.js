import{_ as a,o as e,c as t,V as o}from"./chunks/framework.ec431b68.js";const _=JSON.parse('{"title":"kafka","description":"","frontmatter":{},"headers":[],"relativePath":"guide/kafka.md","filePath":"guide/kafka.md","lastUpdated":1684773409000}'),r={name:"guide/kafka.md"},i=o('<h1 id="kafka" tabindex="-1">kafka <a class="header-anchor" href="#kafka" aria-label="Permalink to &quot;kafka&quot;">​</a></h1><p>Kafka传统定义：Kafka是一个分布式的基于发布/订阅模式的消息队列(Message Queue)，主要应用于大数据实时处理领域。</p><p>Kafka最新定义：Kafka是一个开源的分布式事件流平台(Event Streaming Platform)，被数千家公司用于高性能数据管道、流分析、数据集成和关键任务应用。</p><h2 id="消息队列" tabindex="-1">消息队列 <a class="header-anchor" href="#消息队列" aria-label="Permalink to &quot;消息队列&quot;">​</a></h2><p>目前企业中比较常见的消息队列产品主要有Kafka、ActiveMQ、RabbitMQ、RocketMQ等。</p><p>在大数据场景主要采用Kafka作为消息队列。在JavaEE开发中主要采用ActiveMQ、RabbitMQ、RocketMQ。</p><h3 id="传统消息队列的应用场景" tabindex="-1">传统消息队列的应用场景 <a class="header-anchor" href="#传统消息队列的应用场景" aria-label="Permalink to &quot;传统消息队列的应用场景&quot;">​</a></h3><p>传统的消息队列的主要应用场景包括：缓存/消峰、解耦和异步通信</p><p>缓冲/消峰：有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况</p><p>解耦：允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束</p><p>异步通信：允许用户把一个消息放入队列，但并不立即处理它，然后在需要的时候再去处理它们。</p><h3 id="消息队列的两种方式" tabindex="-1">消息队列的两种方式 <a class="header-anchor" href="#消息队列的两种方式" aria-label="Permalink to &quot;消息队列的两种方式&quot;">​</a></h3><p>点对点模式：消费者主动拉取数据，消息收到后清除信息</p><p>发布/订阅模式：可以有多个topic主题(浏览、点赞、收藏、评论等)，消费者消费数据之后，不删除数据，每个消费者相互独立，都可以消费到数据</p><h2 id="集成springboot" tabindex="-1">集成SpringBoot <a class="header-anchor" href="#集成springboot" aria-label="Permalink to &quot;集成SpringBoot&quot;">​</a></h2><p>SpringBoot是一个在JavaEE开发中非常常用的组件。可以用于Kafka的生产者，也可以用于SpringBoot的消费者。</p>',16),n=[i];function p(s,c,k,d,h,l){return e(),t("div",null,n)}const u=a(r,[["render",p]]);export{_ as __pageData,u as default};
